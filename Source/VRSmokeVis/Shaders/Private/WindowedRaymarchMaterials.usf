// Copyright 2021 Tomas Bartipan and Technical University of Munich.
// Licensed under MIT license - See License.txt for details.
// Special credits go to : Temaran (compute shader tutorial), TheHugeManatee (original concept, supervision) and Ryan Brucks
// (original raymarching code).

#include "RaymarchMaterialCommon.usf"
#include "WindowedSampling.usf"

int3 GetVolumeLoadingDimensions(Texture3D Volume)
{
	int x, y, z;
	Volume.GetDimensions(x, y, z);
	// Decrease dimensions by 1, because with any UVW coord being == 1, we would load one after the array length
	// E.G - with X dimension == 2, U == 1, we want to sample x[1], not x[2] (as that doesn't exist)
	return int3(x - 1, y - 1, z - 1);
}

// Performs one raymarch step and accumulates the result to the existing Accumulated Light Energy.
// Notice "Material.Clamp_WorldGroupSettings" used as a sampler. These are UE shared samplers.
void AccumulateWindowedRaymarchStep(inout float4 AccumulatedLightEnergy, float3 CurPos, Texture3D DataVolume,
                                    SamplerState DataVolumeSampler, Texture2D TF, float StepSize,
                                    float4 WindowingParams)
{
	float4 ColorSample = SampleWindowedVolumeStep(CurPos, StepSize, DataVolume, DataVolumeSampler,
	                                              TF, Material.Clamp_WorldGroupSettings, WindowingParams);

	// Accumulate current colored sample to the final values.
	AccumulateLightEnergy(AccumulatedLightEnergy, ColorSample);
}

// Performs raymarch for the current pixel.
float4 PerformWindowedRaymarch(Texture3D DataVolume, // Data Volume 
                               SamplerState DataVolumeSampler,
                               Texture2D TF, // Transfer function texture.
                               float3 CurPos, float Thickness,
                               // CurPos = Entry Position, Thickness is thickness of cube along the ray. Both in UVW space.
                               float StepCount,
                               // How many steps we should take. Actual number of steps taken is StepCount * Thickness.
                               float4 WindowingParams,
                               FMaterialPixelParameters MaterialParameters) // Material Parameters provided by UE.
{
	// StepSize in UVW is inverse to StepCount.
	float StepSize = 1 / StepCount;
	// Actual number of steps to take to march through the full thickness of the cube at the ray position.
	float FloatActualSteps = StepCount * Thickness;
	// Number of full steps to take.
	int MaxSteps = floor(FloatActualSteps);
	// Size of the last (not a full-sized) step.
	float FinalStep = frac(FloatActualSteps);

	// Get camera vector in local space and multiply it by step size.
	float3 LocalCamVec = -normalize(mul(MaterialParameters.CameraVector,
	                                    GetPrimitiveData(MaterialParameters.PrimitiveId).WorldToLocal)) * StepSize;
	// Get step size in local units to get consistent opacity at different volume scale and to be consistent with compute shaders' opacity calculations.
	float StepSizeWorld = VOLUME_DENSITY * StepSize;
	// Initialize accumulated light energy.
	float4 LightEnergy = 0;
	// Jitter Entry position to avoid artifacts.
	JitterEntryPos(CurPos, LocalCamVec, MaterialParameters);

	int i = 0;
	for (i = 0; i < MaxSteps; i++)
	{
		CurPos += LocalCamVec;
		// Because we jitter only "against" the direction of LocalCamVec, start marching before first sample.

		AccumulateWindowedRaymarchStep(LightEnergy, CurPos, DataVolume, DataVolumeSampler, TF, StepSizeWorld,
		                               WindowingParams);

		// Exit early if light energy (opacity) is already very high (so future steps would have almost no impact on color).
		if (LightEnergy.a > 0.95f)
		{
			LightEnergy.a = 1.0f;
			break;
		}
	}

	// Handle FinalStep (only if we went through all the previous steps and the final step size is above zero)
	if (i == MaxSteps && FinalStep > 0.0f)
	{
		CurPos += LocalCamVec * (FinalStep);
		AccumulateWindowedRaymarchStep(LightEnergy, CurPos, DataVolume, DataVolumeSampler, TF,
		                               StepSizeWorld * FinalStep, WindowingParams);
	}

	return LightEnergy;
}
